<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SET THEORY</title>
    <link href="/2024/10/27/set-theory/"/>
    <url>/2024/10/27/set-theory/</url>
    
    <content type="html"><![CDATA[<div style="text-align: center;">  <strong>welcome to the world of set theory!</strong></div><h1>ZFC公理系统</h1><hr><ul><li>1.<strong>外延公理</strong>（Axiom of Extensionality）：</li></ul><blockquote><p>∀u(u∈A⇔u∈B)⇒A=B,而反过来，如果A=B，那么∀u(u∈A⇔u∈B)，所以我们可以得到，A=B⇔∀u(u∈A⇔u∈B)。这表明：一个集合由它的元素所决定(更加显浅易懂的解释是，如果两个集合的元素完全相同，那么这两个集合就是相等的。)</p></blockquote><hr><ul><li>2.<strong>空集公理</strong>（Axiom of Empty Set）：</li></ul><hr><ul><li>先补充一个公理，严格来说，空集并不是凭空产生的，而是由分离公理模式定义的，排除了人类自然语言的局限性</li><li><strong>分离公理模式</strong>（Axiom Schema of Separation）：</li><li>对于任意集合u和任意性质P(x)，存在一个集合<strong>A</strong>，A={x|u∈A∧P(x)}，即<strong>A</strong>是u中所有满足性质<strong>P</strong>的元素构成的集合</li><li>其意思是：对于任意集合u，我们可以从u中分离出满足性质<strong>P</strong>的元素，构成一个新的集合<strong>A</strong>，也就是这一条公理包含了无数条公理</li><li>现在构造空集：根据外延公理，存在一个集合<strong>X</strong>，根据分离公理模式，{x∈X|x≠x}是一个集合，记X={x∈X|x≠x},B={x∈Y|x≠x},现证明<strong>A=B</strong>：</li><li>根据外延公理：∀A∀B(∀x(x∈A⇔x∈B)⇔A=B),只需检查∀<strong>A</strong>和<strong>B</strong>，∀x(x∈A⇔x∈B)是否成立，由于A={x∈X|x≠x}，∀x,x∈A不成立，则x∈A-&gt;x∈B,同理，∀x,x∈B-&gt;x∈A,所以∀x(x∈A⇔x∈B)成立，所以A=B，所以{x∈X|x≠x}是唯一的，我们将这个集合记为∅</li></ul><blockquote><p><strong>∃A,∀x:(v∉u)(∃A,∀x:¬(x∈A))</strong><br>换句话说：有着一个集合，没有任何集合是他的元素<br>根据外延公理，这个集合有且只有一个，我们称之为空集，记作∅<br>有了这些，我们就可以解决罗素悖论了：</p></blockquote><ul><li>回想一下罗素悖论是怎么产生的。我们先是定义了 <strong><em>B={x∣x∉x}</em></strong>，并推出了B∈B→B∉B以及 B∈B←B∉B，从而引起了矛盾。为了解决罗素悖论，我们只需要使它们其中一个不成立即可。我们将要使后者不成立。推导如下：</li></ul><blockquote><p>(1)根据分离公理，可以定义 B={x∈A|x∉x}。称x∉x为性质φ</p></blockquote><blockquote><p>(2)假设 B∈B，则根据 <strong>B</strong>的定义，<strong>B</strong>满足性质φ，即 B∉B，矛盾！所以只能有B∉B。</p></blockquote><blockquote><p>(3)接下来我们证明 B∉A。我们用<em>反证法</em>。假设B∈A。</p></blockquote><blockquote><p>一方面，根据(2),B∉B，即 B满足性质φ。</p></blockquote><blockquote><p>另一方面，根据我们的假设，有B∈A。</p></blockquote><blockquote><p>所以<strong>B</strong>属于<strong>A</strong>且<strong>B</strong>满足性质φ。根据<strong>B</strong>的定义,B∈B，这与(2)矛盾！所以 B∉A。</p></blockquote><blockquote><p>既然B∉A，那么B∉B 就不能推出B∈B</p></blockquote><blockquote><p>这样我们就解决了罗素悖论，即集合<strong>B</strong>不属于自身，仅此而已，没有矛盾发生。</p></blockquote><blockquote><p>如果你觉得这一切发生的太快，我下面再用更自然的语言描述一遍。本来我们是凭空地用性质“<strong><em>不属于自己</em></strong>”来定义一个集合<strong>B</strong>,而分离公理模式告诉我们这样做不行。这就是问题的关键！我们必须要从一个已有的集合<strong>A</strong>分离出新的集合<strong>B</strong>，而<strong>A</strong>被证明是不含有元素<strong>B</strong>的，从而“<strong><em>B不属于自己</em></strong>”不能推出“<strong><em>B属于自己</em></strong>”。注意到从“<strong><em>B不属于B</em></strong>”推出“<strong><em>B属于B</em></strong>”还需要一个条件，就是“<strong><em>B属于A</em></strong>”。</p></blockquote><blockquote><p>再换句话说，罗素悖论的关键在于“<strong><em>自我指代</em></strong>”，而分离公理消除了“<strong><em>自我指代</em></strong>”的可能。<strong>B</strong>指代的只有<strong>A</strong>中的元素，而不是任何元素都能被B的定义指代。</p></blockquote><blockquote><p>以上的分析还证明了，对于任何一个集合<strong>A</strong>，总有一个集合B={x∈A|x∉x}不属于<strong>A</strong>(根据(3))。因此，所有集合构成的集合是不存在的，或者说，包含一切的集合是不存在的。</p></blockquote><hr><ul><li>3.<strong>配对公理</strong>（Axiom of Pairing）：</li></ul><hr><blockquote><p>对于任意两个对象a和b，存在一个集合C，C={a,b},只包含a和b两个元素，即</p></blockquote><ul><li>∀a ∀b ∃C ∀x ( x ∈ C ↔ x = a ∨ x = b )</li></ul><blockquote><p>即 ，C中元素只能是a或b，根据外延性公理，可以证明该集合是唯一的<br>对两个元素a，做配对，有集合C={a,a},即：∃C∀x(x∈C⇔x=a)<br>根据外延性公理，由C={a,a}={a}，即集合中元素是唯一的<br>根据外延性公理，可以得出：{a,b}={b,a}//也就是集合的无序性</p></blockquote><hr><ul><li>4.<strong>并集公理</strong>（Axiom of Union）：</li></ul><hr><blockquote><p>任给一个集合X，都有一个恰好由X的元素的全体元素构成的集合，即<br><strong>∀X ∃Y ∀z (z∈Y ↔ ∃w (w∈X ∧ z∈w))</strong><br>根据分离公理模式和外延公理，可以定义交集：<br>⋂__<em>A</em><strong>:={x∈⋃A|∀B∈</strong><em>A</em>__,x∈A},其中 <strong><em>A</em></strong> 是一族集合的集合，记为为</p></blockquote><ul><li><strong>⋂{A,B}={x|x∈A∧x∈B}=A⋂B</strong><br>差集也可定义，在此略去</li><li>在此，我们定义自然数：</li></ul><blockquote><p>First,we define 0=∅,1={∅},then 2={0,{0}},3={0,1,{0,1}},…<br>we define successor(后继):<br>S(x):=x∪{x} &quot;:&quot;是define的意思，注意到，0不是任何自然数的后继<br>但是很遗憾，我们现在并不能定义自然数集(见无穷公理)</p></blockquote><hr><ul><li>5.<strong>幂集公理</strong>（Axiom of Power Set）：</li></ul><hr><blockquote><p><strong>∀X ∃Y ∀z (z∈Y ↔ z⊆X)</strong><br>它的意思是，可以将一个集合的所有子集作为元素，构造一个新的集合。我们把这个集合叫做原来集合的幂集，记为 P(X).</p></blockquote><hr><ul><li>6.<strong>无穷公理</strong>（Axiom of Infinity）：</li></ul><hr><blockquote><p><strong>∃u(∅∈u∧∀x(x∈u⇒x∪{x}∈u))</strong><br>即存在一个集合X，∅∈X，∀x∈X，x∪{x}∈X(后继)，根据外延性公理，可以证明该集合是唯一的，我们记为N，即N={∅,{∅},{∅,{∅}},…}，即N是自然数集</p></blockquote><hr><ul><li>7.<strong>正则性公理</strong>（Axiom of Regularity）：</li></ul><hr><blockquote><p><strong>∀X(∃Y(Y∈X∧Y⋂X=∅)⇒∃Y(Y∈X∧∀Z(Z∈Y⇒Z⋂X=∅)))</strong><br>这表明在任何非空集合x中，都有对于&quot;∈&quot;的最小元素y。换句话说，在任何非空集合x中，都存在一个元素y，使得x中没有元素属于y</p></blockquote><hr><ul><li>8.<strong>替代公理模式</strong>（Axiom Schema of Replacement）：</li></ul><hr><blockquote><p><strong>∀A∃B(B={y|∃x(x∈A∧P(x,y))})</strong><br>即对于任意集合A，存在一个集合B，B是由A中元素通过映射P(x,y)得到的，其中P(x,y)是定义在A上的二元函数，即对于任意x∈A，P(x,y)有唯一值y，且y∈B，这样我们可以得到各种各样的可数无穷集。例如，定义φ为φ(x,y):y=2x。可以构造偶数集，但是这样只能得到可数无穷集，于是我们通过幂集公理，可以构造基数更大的无穷集</p></blockquote><hr><ul><li>9.<strong>选择公理</strong>（Axiom of Choice）：</li></ul><p>这九条公里是集合论的基础，解决了罗素悖论,是现代数学的基石</p><h1>离散数学（xtu-王婷）</h1><h2 id="Chapter-1">Chapter 1</h2><h4 id="基本概念：">基本概念：</h4><h4 id="1-有序组：">- 1.有序组：</h4><blockquote><p>&lt;a,b&gt;={a,{a,b}}</p></blockquote><p>理解：第一个元素出现在每个子集合中 , 第二个元素只出现在一个子集合中 , 通过这种方式 , 保证了有序对的定义 , 一前一后两个元素 , 前后顺序不同 , 对应的有序对不同</p><blockquote><p>以下两个是不同的有序对<br>&lt;a,b&gt;={a,{a,b}}<br>&lt;b,a&gt;={b,{a,b}}</p></blockquote><ul><li>引理1：{x,a}={x,b}⇔a=b</li><li>引理2: 若 <strong><em>A</em></strong> = <strong><em>B</em></strong> ≠ ∅,则有</li></ul><blockquote><p>⋃ <strong><em>A</em></strong>=⋃ <strong><em>B</em></strong><br>⋂ <strong><em>A</em></strong>=⋂ <strong><em>B</em></strong></p></blockquote><ul><li>引理3: &lt;a,b&gt;=&lt;c,d&gt;⇔a=c∧b=d</li><li>推论：a≠b⇒&lt;a,b&gt;≠&lt;b,a&gt;</li><li>n元有序组(递归定义)：</li></ul><blockquote><p>n=2时，&lt;a<sub>1</sub>,a<sub>2</sub>&gt;={a<sub>1</sub>,{a<sub>1</sub>,a<sub>2</sub>}}<br>n&gt;2时，&lt;a<sub>1</sub>,…,a<sub>n</sub>&gt;=&lt;&lt;a<sub>1</sub>,…,a<sub>n-1</sub>&gt;,a<sub>n</sub>&gt;<br>a<sub>i</sub>称为n元组分第i分量</p></blockquote><p>那么，有了有序组这个概念，我们自然而然的引入笛卡尔积</p><ul><li>笛卡尔积：</li><li>如果有两个集合A和B，那么它们的笛卡尔积A×B是所有可能的有序对(x, y)的集合，其中x是集合A的元素，y是集合B的元素.数学表达式：</li></ul><blockquote><p>A×B = { (x,y) | x ∈ A ∧ y ∈ B }</p></blockquote><ul><li>例子：</li></ul><blockquote><p>A×∅=∅×A=∅<br>R<sup>2</sup>={&lt;x,y&gt;|x,y∈R}，表示笛卡尔平面直角坐标系<br>R<sup>n</sup>={&lt;x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>&gt;|x<sub>i</sub>∈R,i=1,2,…,n}，表示n维笛卡尔坐标系</p></blockquote><p>关于笛卡尔积的运算规律，我不在此讨论</p><ul><li>定理：</li></ul><blockquote><p>对于任意有限集合A<sub>1</sub>,…,A<sub>n</sub>，有|A<sub>1</sub>×…×A<sub>n</sub>|=|A<sub>1</sub>|×…×|A<sub>n</sub>|<br>这表示总步骤=分步骤的乘积，一个例子是阶乘的实际意义</p></blockquote><h4 id="2-关系">- 2.关系</h4><ul><li>关系的运算</li></ul>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>set theory</tag>
      
      <tag>cantor</tag>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The missing semester</title>
    <link href="/2024/10/25/The-missing-semester/"/>
    <url>/2024/10/25/The-missing-semester/</url>
    
    <content type="html"><![CDATA[<ul><li>I’m a beginner int linux, that’s a curriculum I first learned about linux</li></ul><h1>Detail for Liunx shell</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Bash">anfsity@LAPTOP-POLGCBEP:/$ <span class="hljs-built_in">ls</span> -l /home<br>total 4<br>drwxr-x--- 4 anfsity anfsity 4096 Oct 24 12:52 anfsity<br></code></pre></td></tr></table></figure><p>First,the <strong><em>d</em></strong> at the beginning of the line tell us that <strong><em>anfsity</em></strong> is a directory.Then follow three groups of three characters(<strong><em>rwx</em></strong>).These indicate what permissions the owner of the file (<strong><em>anfsity</em></strong>),the owning group (<strong><em>users</em></strong>),and everyone else respectively have on the relevant item.A “<strong><em>-</em></strong>” indicates that the given principal does not have the given permission.Above, only the owner is allowed to modfiy (<strong><em>w</em></strong>) the <strong><em>anfsity</em></strong> directory.(i.e., add/remove files in it).To enter a directory, a user must have “search” (represented by “execute”: <strong><em>x</em></strong>) permissions on that directory (and its parents). To list its contents, a user must have read (<strong><em>r</em></strong>) permissions on that directory. For files, the permissions are as you would expect. Notice that nearly all the files in <strong><em>/bin</em></strong> have the <strong><em>x</em></strong> permission set for the last group, “everyone else”, so that anyone can execute those programs.</p><p>Some other handy programs to know about at this point are <strong><em>mv</em></strong> (to rename/move a file),<strong><em>cp</em></strong> (to copy a file), and <strong><em>mkdir</em></strong> (to make a new directory).</p><p>If you ever want more information about a program’s arguments, inputs, outputs, or how it works in general, give the <strong><em>man</em></strong> program a try. It takes as an argument the name of a program, and shows you its manual page. Press <strong><em>q</em></strong> to exit.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">anfsity:~$ man <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>MIT open source</category>
      
    </categories>
    
    
    <tags>
      
      <tag>The missing semester</tag>
      
      <tag>MIT open source</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Computer Network</title>
    <link href="/2024/10/25/Computer%20Network/"/>
    <url>/2024/10/25/Computer%20Network/</url>
    
    <content type="html"><![CDATA[<h1>Computer Network</h1><h2 id="Curriculm"><a href="https://www.bilibili.com/video/BV1JV411t7ow?vd_source=7222a52d87a973060d3807adee683865&amp;p=2&amp;spm_id_from=333.788.player.switch">Curriculm</a></h2><ul><li>感谢中科大</li><li>这是关于中科大计算机网络课程的笔记</li><li>@郑烇</li></ul><h2 id="Chapter-1">Chapter 1</h2><h3 id="1-1">1.1</h3><div style="text-align: center;">    <img src="/img/1.1.png" alt="1.1" style="max-width: 100%; height: auto;"></div>]]></content>
    
    
    <categories>
      
      <category>Computer Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Computer Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm</title>
    <link href="/2024/10/24/algorithm/"/>
    <url>/2024/10/24/algorithm/</url>
    
    <content type="html"><![CDATA[<h1>Algorithm</h1><h1>Index</h1><ul><li><a href="#1%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a></li><li>[]</li></ul><h2 id="1-滑动窗口">1.滑动窗口</h2><h2 id="2-埃氏筛-前缀和">2.埃氏筛&amp;前缀和</h2><h2 id="3-双指针">3.双指针</h2><h2 id="4-进制转化">4.进制转化</h2><h2 id="5-递归">5.递归</h2><h2 id="6">6.</h2>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>English for cs</title>
    <link href="/2024/10/22/English-for-cs/"/>
    <url>/2024/10/22/English-for-cs/</url>
    
    <content type="html"><![CDATA[<h1>English for cs</h1><ul><li><a href="#english-for-cs">English for cs</a><ul><li><a href="#1-introduction">1. introduction</a></li><li><a href="#first-part">first part</a></li><li><a href="#second-part">second part</a></li></ul></li></ul><h2 id="1-introduction">1. introduction</h2><ul><li>English is vital for computer science，so I have to learn English for cs so that I can found curriculums in foreign universities such as MIT and Harvard.</li><li>When broswsering the Internet, I found countless document ,I almost can’t know whether those document is I need.That makes me very annoyed</li><li>So I write down the words I don’t know and the meaning of those words in this blog.</li><li>I hope that one day I can watch the yutube video without subtitles.</li></ul><hr><h2 id="first-part">first part</h2><ol><li></li></ol><blockquote><p><strong>curriculum</strong><br>/kəˈrɪkjələm/<br>“课程”</p></blockquote><ol start="2"><li></li></ol><blockquote><p>You can bookmark this page to retrieve your key.<br><strong>retrieve</strong><br>/rɪˈtriːv/<br>“检索”</p></blockquote><ol start="3"><li></li></ol><blockquote><p><strong>copilot</strong><br>/ˈpaɪləkəʊˈt/<br>“智能助手”</p></blockquote><ol start="4"><li></li></ol><blockquote><p><strong>elimination</strong><br>/ɪˌlɪmɪˈneɪʃᵊn/<br>“消元”</p></blockquote><ol start="5"><li></li></ol><blockquote><p><strong>entry</strong><br>“元素”</p></blockquote><ol start="6"><li></li></ol><blockquote><p><strong>convert</strong><br>“转换”</p></blockquote><ol start="7"><li></li></ol><blockquote><p><strong>diagonal</strong><br>/daɪˈæɡənəl/<br>“对角线”</p></blockquote><ol start="8"><li></li></ol><blockquote><p><strong>subtracted</strong><br>/səbˈtræktɪd/<br>“减去”</p></blockquote><ol start="9"><li></li></ol><blockquote><p><strong>permute</strong><br>“置换”</p></blockquote><ol start="10"><li></li></ol><blockquote><p><strong>permutation</strong><br>“排列”</p></blockquote><ol start="11"><li></li></ol><blockquote><p><strong>identity matrix</strong><br>“单位矩阵”</p></blockquote><ol start="12"><li></li></ol><blockquote><p>So if two leading <strong>coefficients</strong> are in the same column<br>/ˌkoʊəˈfɪʃənts/<br>“系数”</p></blockquote><ol start="13"><li></li></ol><blockquote><p>Now through application of <strong>elementary</strong> row operations<br>/ˌɛləˈmɛntri/<br>“初等”</p></blockquote><ol start="14"><li></li></ol><blockquote><p>find the <strong>reduced echelon</strong> form of this n × 2n matrix<br>/rəˈdust/ /ˈɛʃəˌlɑn/<br>“简化阶梯”</p></blockquote><ol start="15"><li></li></ol><blockquote><p><strong>Denoting by B the product of these elementary matrices</strong><br>“把这些初等矩阵的乘积记为B”</p></blockquote><ol start="16"><li></li></ol><blockquote><p>Yet many of us <strong>utilize</strong> only a small <strong>fraction</strong> of those tools<br>/ˈjutəˌlaɪz/<br>“利用；部分，分数”</p></blockquote><ol start="17"><li></li></ol><blockquote><p>we only know enough magical <strong><em>incantations by rote</em></strong> to <strong><em>get by</em></strong>, and blindly copy-paste commands from the internet when we <strong><em>get stuck</em></strong><br>/ɪnˈkænˈteɪʃənz/ /baɪ/ /roʊt/<br>“我们只靠死记硬背了一些足以应付的‘魔法咒语’，在遇到困难时就盲目地从网上复制粘贴命令”</p></blockquote><ol start="18"><li></li></ol><blockquote><p><strong><em>instill</em></strong><br>“逐步培养”</p></blockquote><ol start="19"><li></li></ol><blockquote><p>the missing semester<br>“缺失的一学期”<br>“通常指代那些在传统课程中没有教授但对实际操作非常重要的技能或知识”</p></blockquote><ol start="20"><li></li></ol><blockquote><p>We are trying to cover a lot of ground over the course of just 11 1-hour lectures, so the lectures are fairly <strong><em>dense</em></strong>.<br>“密集”</p></blockquote><ol start="21"><li></li></ol><blockquote><p>if something particularly <strong><em>strikes your fancy</em></strong>, don’t hesitate to <strong><em>reach out</em></strong> to us and ask for <strong><em>pointers</em></strong>!<br>“如果有某些内容特别吸引你，不要犹豫，随时联系我们寻求指导！”</p></blockquote><ol start="22"><li></li></ol><blockquote><p><strong><em>fanciful graphical user interfaces</em></strong><br>“梦幻般的图形用户界面”</p></blockquote><ol start="23"><li></li></ol><blockquote><p><strong>* textual *</strong><br>“文本界面”</p></blockquote><ol start="24"><li></li></ol><blockquote><p>and <strong><em>inspect</em></strong> their output in a <strong><em>semi-structured</em></strong> way<br>“并以半结构化的方式检查它们的输出”</p></blockquote><ol start="25"><li></li></ol><blockquote><p><strong><em>syntax</em></strong><br>/ˈsɪnˌtæks/<br>“语法规则”</p></blockquote><ol start="26"><li></li></ol><blockquote><p>When you launch your terminal, you will see a <strong><em>prompt</em></strong> that often looks a little like this<br>/prɑmpt/<br>“提示符”</p></blockquote><ol start="27"><li></li></ol><blockquote><p><strong><em>argument</em></strong><br>“参数”</p></blockquote><ol start="28"><li></li></ol><blockquote><p><strong><em>quote</em></strong><br>&quot;,表示字符串</p></blockquote><ol start="29"><li></li></ol><blockquote><p><strong><em>escape</em></strong><br>“转义”</p></blockquote><ol start="30"><li></li></ol><blockquote><p><strong><em>ship</em></strong><br>“发布”</p></blockquote><ol start="31"><li></li></ol><blockquote><p><strong><em>program</em></strong><br>“编程”</p></blockquote><ol start="32"><li></li></ol><blockquote><p><strong><em>variable</em></strong><br>“变量”</p></blockquote><ol start="33"><li></li></ol><blockquote><p><strong><em>shell scripting</em></strong><br>“shell脚本编写”</p></blockquote><ol start="34"><li></li></ol><blockquote><p><strong><em>Resolves and installs dependencies automatically</em></strong><br>“自动解析和安装依赖项”</p></blockquote><ol start="35"><li></li></ol><blockquote><p><strong><em>Windows 10 client devices restrict execution of any PowerShell scripts by default.</em></strong><br>/ˌɛksəˈkjuʃən/<br>“Windows 10 客户端设备默认限制执行任何 PowerShell 脚本”</p></blockquote><ol start="36"><li></li></ol><blockquote><p><strong><em>complete documentation</em></strong><br>“完整的文档”</p></blockquote><ol start="37"><li></li></ol><blockquote><p>These apps are <strong><em>compressed files</em></strong> which can run <strong><em>standalone</em></strong> after being <strong><em>extracted</em></strong><br>“这些应用程序是压缩文件，解压后可以独立运行”</p></blockquote><ol start="38"><li></li></ol><blockquote><p>This type of apps does not produce <strong><em>side effects</em></strong> like changing the Windows Registry or placing files outside the app directory<br>“这种类型的应用程序不会产生副作用，比如更改 Windows 注册表或将文件放置在应用程序目录之外”</p></blockquote><ol start="39"><li></li></ol><blockquote><p><strong><em>COLOPHON</em></strong><br>出版说明</p></blockquote><ol start="40"><li></li></ol><blockquote><p><strong><em>manual</em></strong><br>手册</p></blockquote><hr><h2 id="second-part">second part</h2><ol><li></li></ol><blockquote><p>Below is a <strong><em>bare minimum guide</em></strong> to get you started<br>以下是一个最低限度的指南，帮助你入门</p></blockquote><ol start="2"><li></li></ol><blockquote><p><strong><em>indicate</em></strong><br>表示</p></blockquote><ol start="3"><li></li></ol><blockquote><p><strong><em>execute</em></strong><br>执行</p></blockquote><ol start="4"><li></li></ol><blockquote><p><strong><em>delimited</em></strong><br>分隔的</p></blockquote><ol start="5"><li></li></ol><blockquote><p><strong><em>disk partition</em></strong><br>磁盘分区</p></blockquote><ol start="6"><li></li></ol><blockquote><p><strong><em>parent directory</em></strong><br>上一级目录</p></blockquote><ol start="7"><li></li></ol><blockquote><p>You can configure your prompt to show you all sorts of useful information, which we will <strong><em>cover</em></strong> in a later lecture<br>讲解</p></blockquote><ol start="8"><li></li></ol><blockquote><p><strong><em>Unless a directory is given as its first argument</em></strong><br>除非第一个参数是一个目录</p></blockquote><ol start="9"><li></li></ol><blockquote></blockquote>]]></content>
    
    
    <categories>
      
      <category>English</category>
      
    </categories>
    
    
    <tags>
      
      <tag>English</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实数域</title>
    <link href="/2024/10/18/%E5%AE%9E%E6%95%B0%E5%9F%9F/"/>
    <url>/2024/10/18/%E5%AE%9E%E6%95%B0%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<ul><li><strong>起因</strong><br>学校使用的是华东师大的数学分析教材，但我觉得教材的内容不够严谨和完善，缺少完整实分析的很多内容，实数域的构造放到了教材的附录上，且并不完整</li></ul><h3 id="本文基于陶哲轩实分析（第三版）">本文基于陶哲轩实分析（第三版）</h3><ul><li>大部分内容引自原文</li></ul>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>real number</tag>
      
      <tag>real analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数</title>
    <link href="/2024/10/17/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/10/17/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1>线性代数</h1><p><img src="./img/linear.png" alt=""></p><p>线性代数是计算机专业的基础数学，必须要学好<br>吐槽一下，学校自己编的的教材真的很垃圾，不如说，国内的教材大都具有缺陷<br>但是，老师上的课真的 emmm 一言难尽,不多说</p><h2 id="MIT线性代数">MIT线性代数</h2><p><a href="https://ocw.mit.edu/courses/18-06-linear-algebra-spring-2010/download/">mit linear algebra open source</a></p><h3 id="第二章-求解线性方程组">第二章 求解线性方程组</h3>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linear algebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xtuoj-part1</title>
    <link href="/2024/10/17/xtuoj/"/>
    <url>/2024/10/17/xtuoj/</url>
    
    <content type="html"><![CDATA[<ul><li>记载刷xtuoj遇到的一些题目</li></ul><h2 id="xtuoj-part1">xtuoj-part1</h2><ul><li><h3 id="目录">目录</h3></li><li><a href="#%E5%88%B7%E6%B2%B9%E6%BC%86">刷油漆</a></li><li><a href="#%E5%AE%8C%E7%BE%8E%E5%9B%9E%E6%96%87%E6%95%B0">完美回文数</a></li><li><a href="#%E6%9C%80%E5%A4%9A%E7%9A%84%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2">最多的可变字符串</a></li><li><a href="#%E9%9D%92%E8%9B%99">青蛙</a></li><li><a href="#%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B02">完全平方数2</a></li><li><a href="#%E6%8B%BC%E5%9B%BE">拼图</a></li><li><a href="#prime-palindromes">Prime Palindromes</a></li></ul><h3 id="刷油漆">刷油漆</h3><ul><li>先上题 <a href="https://oj.xtu.edu.cn/problem.php?cid=1007&amp;pid=7">刷油漆</a></li></ul><blockquote><p>题目大意 n,m,c,t表示行数，列数，颜色数，刷漆次数<br>谢大以前给研究生出的压轴题，还是具有一定的思维难度的<br>算法的核心在于构建O(T)的代码<br>突破点在于将操作顺序和读入顺序倒置<br>掌握了这点，剩下的就可以顺利突破了<br>上代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> colorCount[<span class="hljs-number">1010</span>];       <span class="hljs-comment">// 记录每种颜色的格子数量</span><br><span class="hljs-type">int</span> rowPainted[<span class="hljs-number">10010</span>];      <span class="hljs-comment">// 记录某行是否已被刷过</span><br><span class="hljs-type">int</span> colPainted[<span class="hljs-number">10010</span>];      <span class="hljs-comment">// 记录某列是否已被刷过</span><br><span class="hljs-type">int</span> paintOps[<span class="hljs-number">3</span>][<span class="hljs-number">100005</span>];    <span class="hljs-comment">// 记录所有刷漆操作</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> rows, cols, colors, operations;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;rows, &amp;cols, &amp;colors, &amp;operations);<br>    <br>    <span class="hljs-comment">// 读取每个操作</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= operations; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;paintOps[<span class="hljs-number">0</span>][i], &amp;paintOps[<span class="hljs-number">1</span>][i], &amp;paintOps[<span class="hljs-number">2</span>][i]);<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> paintedRows = <span class="hljs-number">0</span>, paintedCols = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录被刷过的行数和列数</span><br>    <br>    <span class="hljs-comment">// 从后往前遍历所有操作，保证逆序优先级</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = operations; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span>(paintOps[<span class="hljs-number">0</span>][i] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 如果是行操作</span><br>            <span class="hljs-keyword">if</span>(!rowPainted[paintOps[<span class="hljs-number">1</span>][i]]) &#123;  <span class="hljs-comment">// 如果该行未被刷过</span><br>                rowPainted[paintOps[<span class="hljs-number">1</span>][i]] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记该行被刷过</span><br>                colorCount[paintOps[<span class="hljs-number">2</span>][i]] += cols - paintedCols;  <span class="hljs-comment">// 该行颜色的格子数增加（总列数 - 被刷过的列数）</span><br>                paintedRows++;  <span class="hljs-comment">// 被刷过的行数加1</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 如果是列操作</span><br>            <span class="hljs-keyword">if</span>(!colPainted[paintOps[<span class="hljs-number">1</span>][i]]) &#123;  <span class="hljs-comment">// 如果该列未被刷过</span><br>                colPainted[paintOps[<span class="hljs-number">1</span>][i]] = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 标记该列被刷过</span><br>                colorCount[paintOps[<span class="hljs-number">2</span>][i]] += rows - paintedRows;  <span class="hljs-comment">// 该列颜色的格子数增加（总行数 - 被刷过的行数）</span><br>                paintedCols++;  <span class="hljs-comment">// 被刷过的列数加1</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 按颜色编号从小到大输出每种颜色的格子数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= colors; i++) &#123;<br>        <span class="hljs-keyword">if</span>(colorCount[i]) &#123;  <span class="hljs-comment">// 只输出数量不为0的颜色</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, colorCount[i]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    solve();  <span class="hljs-comment">// 直接调用一次solve函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p><h3 id="完美回文数">完美回文数</h3><ul><li><a href="https://oj.xtu.edu.cn/problem.php?cid=1005&amp;pid=1">perfect palindrome Number</a></li><li>1e5内的完美回文数只有三个{11，1001，1111}</li><li>输入T(样例数)，n(数据)</li><li>输出：每行输出一个样例的结果，如果n不能由完美回文数累加得到，输出0</li><li>思路：动态规划</li><li>很正常，如果从n反推由多少个pre_pal组成，思路会很复杂且不清楚，但是我倒过来思考</li><li><blockquote><p>如果我提前把所有完美回文数可能的组成情况预先计算并储存进入数组，思路就会清楚很多</p></blockquote></li><li><blockquote><p>而且也很容易实现代码，甚至时间复杂度是O(T);</p></blockquote></li><li><s>真是优雅啊</s></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;limits.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 100000</span><br><br><span class="hljs-type">int</span> dp[MAX+<span class="hljs-number">1</span>]=&#123;&#125;;<br><span class="hljs-type">int</span> pre_pal[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">11</span>,<span class="hljs-number">1001</span>,<span class="hljs-number">1111</span>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=MAX;i++)<br>    &#123;<br>dp[i]=INT_MAX;<span class="hljs-comment">//每个dp赋值为int类型的最大值，而dp[0]是dp的开始</span><br>&#125;<br><span class="hljs-comment">//核心代码</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=MAX;i++)<br>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)&#123;<br><span class="hljs-keyword">if</span>(i&gt;=pre_pal[j]&amp;&amp;dp[i-pre_pal[j]!=INT_MAX])<span class="hljs-comment">//i表示在1e5内可以由三个完美回文数生成的值</span><br>            &#123;<br>dp[i]=(dp[i]&lt;dp[i-pre_pal[j]]+<span class="hljs-number">1</span>)?dp[i]:dp[i-pre_pal[j]]+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>        <span class="hljs-comment">//举个例子，首次出现由完美回文数组成的整数是11，就有dp[11]=1</span><br>        <span class="hljs-comment">//dp[22]-&gt;dp[11]+1=2,dp[33]-&gt;dp[22]+1=3,dp[44]-&gt;dp[33]+1=4,dp[55]-&gt;dp[44]+1=5直到dp[1001]出现，此时又像dp[11]一样，记为1</span><br>        <span class="hljs-comment">//当第一个特殊的n出现时，1012，这么说吧，1012=1001+11，而循环是从小的pre_pal开始的，第一个检查的值就是1012-11</span><br>        <span class="hljs-comment">//所以，dp[1012]=dp[1001]+dp[11]=(1+1=2)</span><br>&#125;<br><br><br><span class="hljs-type">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-type">int</span> k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br><span class="hljs-keyword">if</span>(k&lt;=MAX&amp;&amp;dp[k]!=INT_MAX)&#123;<span class="hljs-comment">//如果k是完美回文数的和，输出结果，处理类似于前缀和</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[k]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)<br>&#123;<br><span class="hljs-type">int</span> k;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;k);<br><span class="hljs-keyword">if</span>(k&lt;=MAX&amp;&amp;dp[k]!=INT_MAX)&#123;<span class="hljs-comment">//如果k是完美回文数的和，输出结果，处理类似于前缀和</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,dp[k]);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p><h3 id="最多的可变字符串">最多的可变字符串</h3><ul><li><a href="https://oj.xtu.edu.cn/problem.php?cid=1006&amp;pid=4">最多的可变字符串</a></li><li>模拟题，重在实现代码，思路很直接</li><li>关于&lt;string.h&gt;头文件里的两个函数</li><li>1.<strong>strcpy</strong></li></ul><blockquote><p>strcpy函数用于将一个字符串复制到另一个字符串中，其函数原型为：</p></blockquote><div style="text-align: center">char *strcpy(char *dest, const char *src);</div><blockquote><p>其中，dest为指向目标字符串的指针，src为指向源字符串的指针。strcpy函数会将src指向的字符串复制到dest指向的字符串中，并返回dest指针<br>strcpy函数会复制包括字符串结尾的空字符’\0’在内，因此目标字符串dest必须有足够的空间来存储源字符串</p></blockquote><ul><li>2.<strong>strcmp</strong></li></ul><blockquote><p>strcmp函数用于比较两个字符串的大小，其函数原型为：</p></blockquote><div style="text-align: center">int strcmp(const char *str1, const char *str2);</div><blockquote><p><strong>参数说明</strong>：<br>str1：要比较的第一个字符串。<br>str2：要比较的第二个字符串。<br><strong>返回值</strong>：<br>strcmp 函数返回一个整数，表示两个字符串的比较结果：</p><p>返回 0：表示 str1 和 str2 内容相同。<br>返回正值：表示 str1 按字典顺序大于 str2，即 str1 中第一个不同字符的 ASCII 值大&gt; 于 str2 中对应字符的 ASCII 值。<br>返回负值：表示 str1 按字典顺序小于 str2，即 str1 中第一个不同字符的 ASCII 值小&gt; 于 str2 中对应字符的 ASCII 值。<br><strong>工作原理</strong>：<br>strcmp 逐个比较两个字符串的字符，直到找到第一个不同的字符或其中一个字符串结束（遇到空字符 ‘\0’）。<br>如果字符串在比较之前的部分完全相同且长度不同，则较短的字符串按字典顺序被认为是较小的。</p></blockquote><ul><li>上代码</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> s[<span class="hljs-number">111</span>][<span class="hljs-number">22</span>];<br><span class="hljs-type">char</span> id[<span class="hljs-number">111</span>][<span class="hljs-number">22</span>];<br><span class="hljs-type">int</span> cnt[<span class="hljs-number">111</span>];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* a,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span>&#123;<br><span class="hljs-keyword">return</span> *(<span class="hljs-type">char</span>*)a-*(<span class="hljs-type">char</span>*)b;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> i, j, n, k;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s[i]);<span class="hljs-comment">//读入</span><br>        <span class="hljs-built_in">strcpy</span>(id[i], s[i]);<br>        qsort(s[i], <span class="hljs-built_in">strlen</span>(s[i]), <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), cmp);<span class="hljs-comment">//排序</span><br>    &#125;<br>    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cnt));<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span>(cnt[i] == <span class="hljs-number">0</span>)&#123;<br>            cnt[i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(j = i + <span class="hljs-number">1</span>; j &lt;= n; j++)<br>                <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strcmp</span>(s[i], s[j]) == <span class="hljs-number">0</span>)&#123;<br>                    cnt[i]++;<br>                    cnt[j] = -i;<br>                &#125;<br>        &#125;<br>    k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span>(cnt[i] &gt; cnt[k]) k = i;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, cnt[k]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, id[k]);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>        <span class="hljs-keyword">if</span>(cnt[i] == -k)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, id[i]);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> T;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br><span class="hljs-keyword">while</span>(T--)&#123;<br>    solve();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p><h3 id="青蛙">青蛙</h3><ul><li><a href="https://oj.xtu.edu.cn/problem.php?cid=1004&amp;pid=2">青蛙</a></li></ul><blockquote><p>该题不是很难，本质是一个数学题，找到规律即可做出<br>但是如果没有想到数学方法，就会很困难，纯模拟的思路只有循环队列可以较为轻松的实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>    <span class="hljs-keyword">return</span> b==<span class="hljs-number">0</span>?a:gcd(b,a%b);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;T);<br>    <span class="hljs-keyword">while</span>(T--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);<br>        <span class="hljs-keyword">if</span>(gcd(a,b+<span class="hljs-number">1</span>)==<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//很正常，如果两个数互质，那么两个数取模，就可以取遍所有的可能</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p><h3 id="完全平方数2">完全平方数2</h3><p>找个时间重写一下</p><ul><li><a href="https://oj.xtu.edu.cn/problem.php?cid=1008&amp;pid=6">完全平方数2</a></li></ul><blockquote><p>总结以下这类题型的规律<br>对于给定方程的求解，参变分离，把方程转化成两个因式相乘=一个已知数的形式<br>枚举其中两个因式，解方程，判断是否符合条件即可<br>所以，重点就在于怎么构造方程</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cramer_del</span><span class="hljs-params">(ll a1, ll b1, ll c1, ll a2, ll b2, ll c2, <span class="hljs-type">double</span> *x1, <span class="hljs-type">double</span> *x2)</span> &#123;<br>    ll D = a1 * b2 - a2 * b1;<br>    ll D1 = c1 * b2 - c2 * b1;<br>    ll D2 = a1 * c2 - a2 * c1;<br>    *x1 = (<span class="hljs-type">double</span>)D1 / D;<br>    *x2 = (<span class="hljs-type">double</span>)D2 / D;<br>&#125;<span class="hljs-comment">//克莱姆法则</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> &#123;<br>    <span class="hljs-keyword">return</span> (*(ll *)a - *(ll *)b);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> T;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        ll b, c;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;b, &amp;c);<br>        ll sum = <span class="hljs-number">4</span> * c - b * b;<br><br>        <span class="hljs-keyword">if</span> (sum == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        ll solutions[<span class="hljs-number">2000</span>];  <span class="hljs-comment">// 用于存储解</span><br>        <span class="hljs-type">int</span> solution_count = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (ll f = <span class="hljs-number">1</span>; f * f &lt;= llabs(sum); f++) &#123;<span class="hljs-comment">//添加绝对值，因为sum可能为负数</span><br>            <span class="hljs-keyword">if</span> (sum % f == <span class="hljs-number">0</span>) &#123;<br>                ll factors[<span class="hljs-number">2</span>] = &#123;f, sum / f&#125;;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>                    ll factor = factors[i];<br>                    <span class="hljs-type">double</span> x, t;<br>                    cramer_del(<span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, factor + b, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, sum / factor - b, &amp;x, &amp;t);<br><br>                    <span class="hljs-keyword">if</span> (x == (ll)x &amp;&amp; x &gt; <span class="hljs-number">0</span>) &#123;<br>                        solutions[solution_count++] = (ll)x;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (solution_count == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            qsort(solutions, solution_count, <span class="hljs-keyword">sizeof</span>(ll), compare);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; solution_count; i++) &#123;<br>                <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, solutions[i]);<br>            &#125;<span class="hljs-comment">//满足输出格式</span><br>        &#125;<br>        <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p><h3 id="拼图">拼图</h3><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p><h3 id="prime-palindromes">prime palindromes</h3><p><strong>problem</strong></p><ul><li><a href="https://www.luogu.com.cn/problem/P1217">Prime Palindromes</a></li></ul><blockquote><p>本题是在洛谷上的题<br>其实说明和提示在题目里面就有了<br>本题重要的是先生成所有的回文质数，然后再判断是否符合条件<br>否则，TLE警告<br>详细讲解在注释</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 检查一个数是否为质数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;           <span class="hljs-comment">// 小于等于1的数不是质数</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 2和3是质数</span><br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 任何偶数和3的倍数不是质数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">5</span>; i * i &lt;= n; i += <span class="hljs-number">6</span>) &#123;        <span class="hljs-comment">// 从5开始检查因子，每次增量为6（检查6k±1的形式）</span><br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span> || n % (i + <span class="hljs-number">2</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 如果n能被i或i+2整除，则n不是质数</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 如果通过所有测试，n是质数</span><br>&#125;<br><br><span class="hljs-comment">// 生成给定长度的回文数并检查它们是否为质数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generatePalindromes</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> length)</span> </span>&#123;<br>    <span class="hljs-type">int</span> start = <span class="hljs-number">1</span>, end = <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-comment">// 手动计算start和end的值，不使用pow函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; (length + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; ++i) &#123;<br>        start *= <span class="hljs-number">10</span>;  <span class="hljs-comment">// start为10的(length-1)/2次方</span><br>        end *= <span class="hljs-number">10</span>;    <span class="hljs-comment">// end为10的(length)/2次方</span><br>    &#125;<br>    end *= <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 如果长度是奇数</span><br>    <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; end; ++i) &#123;<br>            <span class="hljs-comment">// 生成一个奇数长度的回文数</span><br>            <span class="hljs-type">int</span> palindrome = i;<br>            <span class="hljs-type">int</span> n = i / <span class="hljs-number">10</span>;  <span class="hljs-comment">// 忽略中间的数字，以生成回文数</span><br>            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>                palindrome = palindrome * <span class="hljs-number">10</span> + (n % <span class="hljs-number">10</span>);  <span class="hljs-comment">// 反转数字并附加到palindrome的末尾</span><br>                n /= <span class="hljs-number">10</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 检查生成的回文数是否在[a, b]范围内并且是质数</span><br>            <span class="hljs-keyword">if</span> (palindrome &gt;= a &amp;&amp; palindrome &lt;= b &amp;&amp; <span class="hljs-built_in">isPrime</span>(palindrome)) &#123;<br>                cout &lt;&lt; palindrome &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果长度是偶数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; end; ++i) &#123;<br>            <span class="hljs-type">int</span> palindrome = i;<br>            <span class="hljs-type">int</span> n = i;  <span class="hljs-comment">// 保留完整的数字以生成回文数</span><br>            <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>                palindrome = palindrome * <span class="hljs-number">10</span> + (n % <span class="hljs-number">10</span>);  <span class="hljs-comment">// 反转数字并附加到palindrome的末尾</span><br>                n /= <span class="hljs-number">10</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 检查生成的回文数是否在[a, b]范围内并且是质数</span><br>            <span class="hljs-keyword">if</span> (palindrome &gt;= a &amp;&amp; palindrome &lt;= b &amp;&amp; <span class="hljs-built_in">isPrime</span>(palindrome)) &#123;<br>                cout &lt;&lt; palindrome &lt;&lt; endl;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br><br>    <span class="hljs-comment">// 调整a和b，使得b最大为10000000</span><br>    <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">9989899</span>) b = <span class="hljs-number">9989899</span>;<br><br>    <span class="hljs-comment">// 遍历长度为1到7的所有可能的回文数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> length = <span class="hljs-number">1</span>; length &lt;= <span class="hljs-number">7</span>; ++length) &#123;<br>        <span class="hljs-built_in">generatePalindromes</span>(a, b, length);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p>]]></content>
    
    
    <categories>
      
      <category>xtuoj</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oj</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2024/10/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2024/10/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<div style="text-align: center;">    <img src="/img/Konachan (5).jpg" alt="个人图片" style="max-width: 100%; height: auto;"></div><h1>我的第一个个人博客，庆祝！</h1><ul><li><strong>校园网</strong>： tmd抽疯校园网，我的port：22始终无法访问github，就是因为校园网不稳定</li><li><strong>github</strong>： 未知原因，我的github pages始终无法部署，算了，不想说了</li><li><strong>vercel</strong>:  本网站托管在vercel上，但是vercel的默认cdn在国外，国内无法访问</li><li><strong>阿里云</strong>：  忍痛斥一元巨资在阿里云上购买了了顶级域名，一年时长，续费好贵啊</li><li><strong><a href="http://us.kg">us.kg</a></strong>:  本来想白嫖的，但是注册失败了，没有找到解决方案</li><li><strong>csdn</strong>： 史！md，依托大的<br>但是学到了git bash的某些语言，算是为以后linux铺路了</li></ul><h2 id="总而言之，我觉得不亏">总而言之，我觉得不亏</h2>]]></content>
    
    
    
    <tags>
      
      <tag>triumph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/02/hello-world/"/>
    <url>/2024/09/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
